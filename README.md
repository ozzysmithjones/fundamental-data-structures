# Fundamental Data Structures
Single header file of fundamental data structures useful in C++ projects. 

# Rationale

I wanted more generic data-structures not provided by the standard library (capped_array, enum_array, enum_bitset). I also made more readable and efficient alternatives to the standard library data-structures. Some differences to the standard library:

- Allocator is not templatized. It is possible to re-use a single allocator for different types.
- No exceptions. No overloaded indexing operator for dynamic_array and other types. Instead the API is designed such that the programmer must consider that an index out of bounds is a possibility. Methods like `element_or` provide a way to access elements with a fallback alternative should the indexing fail. 
- More intuitive names for things. For instance, the equivalent of `std::vector` is called `dynamic_array`. I do not know why programmers keep calling this data structure a `dynamic_array` in parlance and never name it that in the programming language.
- Dynamic array assumes that your types are trivially relocatable, so that it can grow more efficiently. 
- More useful functions like a `contains` function for dynamic_array to see if it contains an element. 

# Why I'm avoiding exceptions

The reason I'm avoiding exceptions is mostly out of personal preference, but there's also some arguments to be made against them in terms of performance/hardware:
- Exceptions can increase binary size.
- Should an exception occur, there's a non-negligible performance cost as the stack unwinds. 
- Exceptions can influence the control-flow graph generated by the compiler, possibily influencing optimizations. 
- Not all platforms support exceptions. 

Taking the above into consideration, here is also my personal arguments against using exceptions:
- In any program, whether that's software for a game or a pacemaker, we should avoid fatal errors as much as possible. In general, an error is just something that "went wrong" and we should mitigate the amount of damage that the error causes to the overall system, so that it can still continue effectively. 
- Addressing the error as close as possible to the source, allows us to address the problem with as much context as possible. If we address the problem far away from the source (like many levels up the call-stack) then we might not have all the information necessary to recover. 
- Addressing problems from far away might mean more destruction to the overall system - to catch an exception we need to unwind the call-stack, and this means calling the destructors of everything on the way. We should, in general, avoid destroying things unless we really have to. 
- The idea that errors are "exceptional" is in my opinion a dangerous mindset to have. The reason we use exceptions is to avoid the syntax of manually typing out `return` many times, but the trade-off is we stop thinking about errors as a real possibility. If we want more reliable software then errors must always be treated as a real possibility and not `throw`n under the carpet.
- The signature of a function does not tell the user whether that function throws an exception. This means that if a user uses a function incorrectly, it might throw without warning and reset to the program back to the last catch block. 

Overall exceptions go against everything that I know about bugs/problems in software. When you encounter a bug, you want to narrow it down to the source and address it there as much as possible with as little damage as possible to the other parts of the program. Exceptions are the opposite of this: destroy everything, including whatevers in the surroundings of the error, and reset the program to the last resetable point. We should avoid whole program resets as much as possible, and only really do it if we have to. It can lead to a bad user-experience in a game (why did the whole level/thing just get reset?), and it can be a disaster in any safety-critical project where resets can't be done without consequences. Sometimes the resets don't even work correctly because the program wasn't built with exception-safety in mind.

As I said though this is mostly just my personal preference and if you like having reset-points in your program like exceptions then that's fine. I just think it's preferable to address issues as close as possible to the source to mitigate negative side-effects. 

# The alternative to Exceptions

This project uses an assertion-based approach. In debug/development builds, asserts that fail will immediately breakpoint, allowing the programmer to diagnose and fix the issue. In release-builds, the asserts still exist but they perform a specified fallback behaviour provided as an argument instead of trapping. Normally the fallback behaviour will just be returning early with an exit code, and the calling code can make things more robust by checking this error code if they care about the result. 

Note that this is a very different approach to just using error-codes. Error-codes by themselves are normally criticised because they can easily be ignored, but here in debug/development builds any issue results in an immediate breakpoint. The programmer can fix the problems that they encounter in debug mode and in release mode the asserts switch to an error-code error-recovery model. The way to deal with errors really depends on the user of the program (programmer/tester/customer), so I think this is the best approach to switch depending on the user of the program. 